// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mesh.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// 
/// Meshtastic protobufs
///
/// For more information on protobufs (and tools to use them with the language of your choice) see
/// https://developers.google.com/protocol-buffers/docs/proto3
///
/// We are not placing any of these defs inside a package, because if you do the
/// resulting nanopb version is super verbose package mesh.
///
/// Protobuf build instructions:
///
/// To build java classes for reading writing:
/// protoc -I=. --java_out /tmp mesh.proto
///
/// To generate Nanopb c code:
/// /home/kevinh/packages/nanopb-0.4.0-linux-x86/generator-bin/protoc --nanopb_out=/tmp -I=app/src/main/proto mesh.proto
/// 
/// Nanopb binaries available here: https://jpa.kapsi.fi/nanopb/download/ use nanopb 0.4.0

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum RouteError: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0

  ///
  /// Our node doesn't have a route to the requested destination anymore.
  case noRoute // = 1

  ///
  /// We received a nak while trying to forward on your behalf
  case gotNak // = 2
  case timeout // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .noRoute
    case 2: self = .gotNak
    case 3: self = .timeout
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .noRoute: return 1
    case .gotNak: return 2
    case .timeout: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RouteError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RouteError] = [
    .none,
    .noRoute,
    .gotNak,
    .timeout,
  ]
}

#endif  // swift(>=4.2)

///
/// Shared constants between device and phone
enum Constants: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// First enum must be zero, and we are just using this enum to
  /// pass int constants between two very different environments
  case unused // = 0

  ///
  /// From mesh.options
  /// note: this payload length is ONLY the bytes that are sent inside of the radiohead packet
  /// Data.payload max_size:240
  case dataPayloadLen // = 240
  case UNRECOGNIZED(Int)

  init() {
    self = .unused
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unused
    case 240: self = .dataPayloadLen
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unused: return 0
    case .dataPayloadLen: return 240
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Constants: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Constants] = [
    .unused,
    .dataPayloadLen,
  ]
}

#endif  // swift(>=4.2)

///
/// The frequency/regulatory region the user has selected.
///
/// Note: In 1.0 builds (which must still be supported by the android app for a
/// long time) this field will be unpopulated.
///
/// If firmware is ever upgraded from an old 1.0ish build, the old
/// MyNodeInfo.region string will be used to set UserPreferences.region and the
/// old value will be no longer set.
enum RegionCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unset // = 0
  case us // = 1
  case eu433 // = 2
  case eu865 // = 3
  case cn // = 4
  case jp // = 5
  case anz // = 6
  case kr // = 7
  case tw // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .unset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .us
    case 2: self = .eu433
    case 3: self = .eu865
    case 4: self = .cn
    case 5: self = .jp
    case 6: self = .anz
    case 7: self = .kr
    case 8: self = .tw
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unset: return 0
    case .us: return 1
    case .eu433: return 2
    case .eu865: return 3
    case .cn: return 4
    case .jp: return 5
    case .anz: return 6
    case .kr: return 7
    case .tw: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RegionCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RegionCode] = [
    .unset,
    .us,
    .eu433,
    .eu865,
    .cn,
    .jp,
    .anz,
    .kr,
    .tw,
  ]
}

#endif  // swift(>=4.2)

///
/// Sets the charge control current of devices with a battery charger that can be
/// configured. This is passed into the axp power management chip like on the tbeam.
enum ChargeCurrent: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case maunset // = 0
  case ma100 // = 1
  case ma190 // = 2
  case ma280 // = 3
  case ma360 // = 4
  case ma450 // = 5
  case ma550 // = 6
  case ma630 // = 7
  case ma700 // = 8
  case ma780 // = 9
  case ma880 // = 10
  case ma960 // = 11
  case ma1000 // = 12
  case ma1080 // = 13
  case ma1160 // = 14
  case ma1240 // = 15
  case ma1320 // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .maunset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .maunset
    case 1: self = .ma100
    case 2: self = .ma190
    case 3: self = .ma280
    case 4: self = .ma360
    case 5: self = .ma450
    case 6: self = .ma550
    case 7: self = .ma630
    case 8: self = .ma700
    case 9: self = .ma780
    case 10: self = .ma880
    case 11: self = .ma960
    case 12: self = .ma1000
    case 13: self = .ma1080
    case 14: self = .ma1160
    case 15: self = .ma1240
    case 16: self = .ma1320
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .maunset: return 0
    case .ma100: return 1
    case .ma190: return 2
    case .ma280: return 3
    case .ma360: return 4
    case .ma450: return 5
    case .ma550: return 6
    case .ma630: return 7
    case .ma700: return 8
    case .ma780: return 9
    case .ma880: return 10
    case .ma960: return 11
    case .ma1000: return 12
    case .ma1080: return 13
    case .ma1160: return 14
    case .ma1240: return 15
    case .ma1320: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ChargeCurrent: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ChargeCurrent] = [
    .maunset,
    .ma100,
    .ma190,
    .ma280,
    .ma360,
    .ma450,
    .ma550,
    .ma630,
    .ma700,
    .ma780,
    .ma880,
    .ma960,
    .ma1000,
    .ma1080,
    .ma1160,
    .ma1240,
    .ma1320,
  ]
}

#endif  // swift(>=4.2)

///
/// How the GPS hardware in this unit is operated.
/// Note: This is independent of how our location is shared with other devices.  For that see LocationSharing
enum GpsOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// This is treated as GpsOpMobile - it is the default settting
  case gpsOpUnset // = 0

  ///
  /// Note: This mode was removed, because it is identical go GpsOpMobile with a gps_update_rate of once per day
  ///
  /// This node is mostly stationary, we should try to get location only once per day,
  /// Once we have that position we should turn the GPS to sleep mode
  /// This is the recommendated configuration for stationary 'router' nodes
  case gpsOpStationary // = 1

  ///
  /// This node is mobile and we should get GPS position at a rate governed by gps_update_rate
  case gpsOpMobile // = 2

  ///
  /// We should only use the GPS to get time (no location data should be acquired/stored)
  /// Once we have the time we treat gps_update_interval as MAXINT (i.e. sleep forever)
  case gpsOpTimeOnly // = 3

  ///
  /// GPS is always turned off - this mode is not recommended - use GpsOpTimeOnly instead
  case gpsOpDisabled // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .gpsOpUnset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gpsOpUnset
    case 1: self = .gpsOpStationary
    case 2: self = .gpsOpMobile
    case 3: self = .gpsOpTimeOnly
    case 4: self = .gpsOpDisabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .gpsOpUnset: return 0
    case .gpsOpStationary: return 1
    case .gpsOpMobile: return 2
    case .gpsOpTimeOnly: return 3
    case .gpsOpDisabled: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension GpsOperation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [GpsOperation] = [
    .gpsOpUnset,
    .gpsOpStationary,
    .gpsOpMobile,
    .gpsOpTimeOnly,
    .gpsOpDisabled,
  ]
}

#endif  // swift(>=4.2)

/// 
/// How our location is shared with other nodes (or the local phone)
enum LocationSharing: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// This is the default and treated as LocEnabled)
  case locUnset // = 0

  ///
  /// We are sharing our location
  case locEnabled // = 1

  ///
  /// We are not sharing our location (if the unit has a GPS it will default to only get time - i.e. GpsOpTimeOnly)
  case locDisabled // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .locUnset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .locUnset
    case 1: self = .locEnabled
    case 2: self = .locDisabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .locUnset: return 0
    case .locEnabled: return 1
    case .locDisabled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension LocationSharing: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [LocationSharing] = [
    .locUnset,
    .locEnabled,
    .locDisabled,
  ]
}

#endif  // swift(>=4.2)

///* Error codes for critical errors
/// 
/// The device might report these fault codes on the screen.  If you encounter a fault code, please
/// post on the meshtastic.discourse.group and we'll try to help.
enum CriticalErrorCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0

  ///
  /// A software bug was detected while trying to send lora
  case txWatchdog // = 1

  ///
  /// A software bug was detected on entry to sleep
  case sleepEnterWait // = 2

  ///
  /// No Lora radio hardware could be found
  case noRadio // = 3

  ///
  /// Not normally used
  case unspecified // = 4

  ///
  /// We failed while configuring a UBlox GPS
  case ubloxInitFailed // = 5

  ///
  /// This board was expected to have a power management chip and it is missing or broken
  case noAxp192 // = 6

  ///
  /// The channel tried to set a radio setting which is not supported by this chipset,
  /// radio comms settings are now undefined.
  case invalidRadioSetting // = 7

  /// Radio transmit hardware failure. We sent data to the radio chip, but it didn't
  /// reply with an interrupt.
  case transmitFailed // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .txWatchdog
    case 2: self = .sleepEnterWait
    case 3: self = .noRadio
    case 4: self = .unspecified
    case 5: self = .ubloxInitFailed
    case 6: self = .noAxp192
    case 7: self = .invalidRadioSetting
    case 8: self = .transmitFailed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .txWatchdog: return 1
    case .sleepEnterWait: return 2
    case .noRadio: return 3
    case .unspecified: return 4
    case .ubloxInitFailed: return 5
    case .noAxp192: return 6
    case .invalidRadioSetting: return 7
    case .transmitFailed: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CriticalErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CriticalErrorCode] = [
    .none,
    .txWatchdog,
    .sleepEnterWait,
    .noRadio,
    .unspecified,
    .ubloxInitFailed,
    .noAxp192,
    .invalidRadioSetting,
    .transmitFailed,
  ]
}

#endif  // swift(>=4.2)

///
/// a gps position
struct Position {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The new preferred location encoding, divide by 1e-7 to get degrees in floating point
  var latitudeI: Int32 = 0

  var longitudeI: Int32 = 0

  ///
  /// In meters above MSL
  var altitude: Int32 = 0

  ///
  /// 1-100 (0 means not provided)
  var batteryLevel: Int32 = 0

  ///
  /// This is usually not sent over the mesh (to save space), but it is sent
  /// from the phone so that the local device can set its RTC If it is sent over
  /// the mesh (because there are devices on the mesh without GPS), it will only
  /// be sent by devices which has a hardware GPS clock.
  /// seconds since 1970
  var time: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// a data message to forward to an external app (or possibly also be consumed
/// internally in the case of CLEAR_TEXT and CLEAR_READACK)
struct DataMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Formerly named typ and of type Type
  var portnum: PortNum = .unknownApp

  ///
  /// Required
  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Broadcast when a newly powered mesh node wants to find a node num it can use
/// Sent from the phone over bluetooth to set the user id for the owner of this node.
/// Also sent from nodes to each other when a new node signs on (so all clients can have this info)
///
/// The algorithm is as follows:
/// when a node starts up, it broadcasts their user and the normal flow is for all
/// other nodes to reply with their User as well (so the new node can build its nodedb)
/// If a node ever receives a User (not just the first broadcast) message where
/// the sender node number equals our node number, that indicates a collision has
/// occurred and the following steps should happen:
///
/// If the receiving node (that was already in the mesh)'s macaddr is LOWER than the
/// new User who just tried to sign in: it gets to keep its nodenum.  We send a
/// broadcast message of OUR User (we use a broadcast so that the other node can
/// receive our message, considering we have the same id - it also serves to let
/// observers correct their nodedb) - this case is rare so it should be okay.
///
/// If any node receives a User where the macaddr is GTE than their local macaddr,
/// they have been vetoed and should pick a new random nodenum (filtering against
/// whatever it knows about the nodedb) and rebroadcast their User.
///
/// A few nodenums are reserved and will never be requested:
/// 0xff - broadcast
/// 0 through 3 - for future use
struct User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// A globally unique ID string for this user.  In the case of
  /// Signal that would mean +16504442323, for the default macaddr
  /// derived id it would be !<6 hexidecimal bytes>
  var id: String = String()

  ///
  /// A full name for this user, i.e. "Kevin Hester"
  var longName: String = String()

  ///
  /// A VERY short name, ideally two characters.  Suitable for a tiny OLED screen
  var shortName: String = String()

  ///
  /// This is the addr of the radio.  Not populated by the phone, but added by the esp32 when broadcasting
  var macaddr: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// A message used in our Dynamic Source Routing protocol (RFC 4728 based)
struct RouteDiscovery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The list of nodes this packet has visited so far
  var route: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// The payload portion fo a packet, this is the actual bytes that are sent
/// inside a radio packet (because from/to are broken out by the comms library)
struct SubPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Only one of the following fields can be populated at a time
  var payload: SubPacket.OneOf_Payload? = nil

  var data: DataMessage {
    get {
      if case .data(let v)? = payload {return v}
      return DataMessage()
    }
    set {payload = .data(newValue)}
  }

  ///
  /// A route request going from the requester
  /// FIXME - these route messages should be moved into regular data packets and use the regular on
  /// device plugin mechanism.
  var routeRequest: RouteDiscovery {
    get {
      if case .routeRequest(let v)? = payload {return v}
      return RouteDiscovery()
    }
    set {payload = .routeRequest(newValue)}
  }

  ///
  /// A route reply
  var routeReply: RouteDiscovery {
    get {
      if case .routeReply(let v)? = payload {return v}
      return RouteDiscovery()
    }
    set {payload = .routeReply(newValue)}
  }

  ///
  /// A failure in a routed message
  var routeError: RouteError {
    get {
      if case .routeError(let v)? = payload {return v}
      return .none
    }
    set {payload = .routeError(newValue)}
  }

  ///
  /// Prior to 1.20 positions were communicated as a special payload type, now they are GPS_POSITION_APP Data
  var position: Position {
    get {
      if case .position(let v)? = payload {return v}
      return Position()
    }
    set {payload = .position(newValue)}
  }

  ///
  /// Prior to 1.20 positions were communicated as a special payload type, now they are MESH_USERINFO_APP
  var user: User {
    get {
      if case .user(let v)? = payload {return v}
      return User()
    }
    set {payload = .user(newValue)}
  }

  ///
  /// Not normally used, but for testing a sender can request that recipient
  /// responds in kind (i.e. if it received a position, it should unicast back it's position).
  /// Note: that if you set this on a broadcast you will receive many replies.
  var wantResponse: Bool = false

  var ack: SubPacket.OneOf_Ack? = nil

  ///
  /// This packet is a requested acknoledgement indicating that we have received
  /// the specified message ID.  This packet type can be used both for immediate
  /// (0 hops) messages or can be routed through multiple hops if dest is set.
  /// Note: As an optimization, recipients can _also_ populate a field in payload
  /// if they think the recipient would appreciate that extra state.
  var successID: UInt32 {
    get {
      if case .successID(let v)? = ack {return v}
      return 0
    }
    set {ack = .successID(newValue)}
  }

  ///
  /// This is a nak, we failed to deliver this message.
  var failID: UInt32 {
    get {
      if case .failID(let v)? = ack {return v}
      return 0
    }
    set {ack = .failID(newValue)}
  }

  ///
  /// The address of the destination node.
  /// This field is is filled in by the mesh radio device software, applicaiton
  /// layer software should never need it.
  /// RouteDiscovery messages _must_ populate this.  Other message types might need
  /// to if they are doing multihop routing.
  var dest: UInt32 = 0

  ///
  /// The address of the original sender for this message.
  /// This field should _only_ be populated for reliable multihop packets (to keep
  /// packets small).
  var source: UInt32 = 0

  ///
  /// Only used in route_error messages.  Indicates the original message ID that
  /// this message is reporting failure on.
  var originalID: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Only one of the following fields can be populated at a time
  enum OneOf_Payload: Equatable {
    case data(DataMessage)
    ///
    /// A route request going from the requester
    /// FIXME - these route messages should be moved into regular data packets and use the regular on
    /// device plugin mechanism.
    case routeRequest(RouteDiscovery)
    ///
    /// A route reply
    case routeReply(RouteDiscovery)
    ///
    /// A failure in a routed message
    case routeError(RouteError)
    ///
    /// Prior to 1.20 positions were communicated as a special payload type, now they are GPS_POSITION_APP Data
    case position(Position)
    ///
    /// Prior to 1.20 positions were communicated as a special payload type, now they are MESH_USERINFO_APP
    case user(User)

  #if !swift(>=4.1)
    static func ==(lhs: SubPacket.OneOf_Payload, rhs: SubPacket.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.routeRequest, .routeRequest): return {
        guard case .routeRequest(let l) = lhs, case .routeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.routeReply, .routeReply): return {
        guard case .routeReply(let l) = lhs, case .routeReply(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.routeError, .routeError): return {
        guard case .routeError(let l) = lhs, case .routeError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.position, .position): return {
        guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.user, .user): return {
        guard case .user(let l) = lhs, case .user(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum OneOf_Ack: Equatable {
    ///
    /// This packet is a requested acknoledgement indicating that we have received
    /// the specified message ID.  This packet type can be used both for immediate
    /// (0 hops) messages or can be routed through multiple hops if dest is set.
    /// Note: As an optimization, recipients can _also_ populate a field in payload
    /// if they think the recipient would appreciate that extra state.
    case successID(UInt32)
    ///
    /// This is a nak, we failed to deliver this message.
    case failID(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: SubPacket.OneOf_Ack, rhs: SubPacket.OneOf_Ack) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.successID, .successID): return {
        guard case .successID(let l) = lhs, case .successID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.failID, .failID): return {
        guard case .failID(let l) = lhs, case .failID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

///
/// A full packet sent/received over the mesh
/// Note: For simplicity reasons (and that we want to keep over the radio packets
/// very small, we now assume that there is only _one_ SubPacket in each MeshPacket).
struct MeshPacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The sending node number.
  /// Note: Our crypto implementation uses this field as well.  See
  /// docs/software/crypto.md for details.
  /// FIXME - really should be fixed32 instead, this encoding only hurts the ble link though.
  var from: UInt32 {
    get {return _storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  ///
  /// The (immediate) destination for this packet.  If we are using routing, the
  /// final destination will be in payload.dest
  /// FIXME - really should be fixed32 instead, this encoding only
  /// hurts the ble link though.
  var to: UInt32 {
    get {return _storage._to}
    set {_uniqueStorage()._to = newValue}
  }

  ///
  /// If set, this indicates the index in the secondary_channels table that this packet 
  /// was sent/received on.  If unset, packet was on the primary channel.
  /// A particular node might know only a subset of channels in use on the mesh.  Therefore channel_index
  /// is inherently a local concept and meaningless to send between nodes.
  var channelIndex: UInt32 {
    get {return _storage._channelIndex}
    set {_uniqueStorage()._channelIndex = newValue}
  }

  var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  var decoded: SubPacket {
    get {
      if case .decoded(let v)? = _storage._payload {return v}
      return SubPacket()
    }
    set {_uniqueStorage()._payload = .decoded(newValue)}
  }

  var encrypted: Data {
    get {
      if case .encrypted(let v)? = _storage._payload {return v}
      return Data()
    }
    set {_uniqueStorage()._payload = .encrypted(newValue)}
  }

  ///
  /// A unique ID for this packet.  Always 0 for no-ack packets or non broadcast
  /// packets (and therefore take zero bytes of space).  Otherwise a unique ID for
  /// this packet, useful for flooding algorithms.
  /// ID only needs to be unique on a _per sender_ basis, and it only
  /// needs to be unique for a few minutes (long enough to last for the length of
  /// any ACK or the completion of a mesh broadcast flood).
  /// Note: Our crypto implementation uses this id as well.  See docs/software/crypto.md for details.
  /// FIXME - really should be fixed32 instead, this encoding only
  /// hurts the ble link though.
  var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///
  /// The time this message was received by the esp32 (secs since 1970).  Note:
  /// this field is _never_ sent on the radio link itself (to save space) Times
  /// are typically not sent over the mesh, but they will be added to any Packet
  /// (chain of SubPacket) sent to the phone (so the phone can know exact time of reception)
  var rxTime: UInt32 {
    get {return _storage._rxTime}
    set {_uniqueStorage()._rxTime = newValue}
  }

  ///
  /// *Never* sent over the radio links.  Set during reception to indicate the SNR
  /// of this packet.  Used to collect statistics on current link waulity.
  var rxSnr: Float {
    get {return _storage._rxSnr}
    set {_uniqueStorage()._rxSnr = newValue}
  }

  ///
  /// If unset treated as zero (no fowarding, send to adjacent nodes only)
  /// if 1, allow hopping through one node, etc...
  /// For our usecase real world topologies probably have a max of about 3.
  /// This field is normally placed into a few of bits in the header.
  var hopLimit: UInt32 {
    get {return _storage._hopLimit}
    set {_uniqueStorage()._hopLimit = newValue}
  }

  ///
  /// This packet is being sent as a reliable message, we would prefer it to arrive
  /// at the destination.  We would like to receive a ack packet in response.
  /// Broadcasts messages treat this flag specially: Since acks for broadcasts would
  /// rapidly flood the channel, the normal ack behavior is suppressed.  Instead,
  /// the original sender listens to see if at least one node is rebroadcasting this
  /// packet (because naive flooding algoritm).  If it hears that the odds (given
  /// typical LoRa topologies) the odds are very high that every node should
  /// eventually receive the message.  So FloodingRouter.cpp generates an implicit
  /// ack which is delivered to the original sender. If after some time we don't
  /// hear anyone rebroadcast our packet, we will timeout and retransmit, using the regular resend logic.
  /// Note: This flag is normally sent in a flag bit in the header when sent over the wire
  var wantAck: Bool {
    get {return _storage._wantAck}
    set {_uniqueStorage()._wantAck = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Payload: Equatable {
    case decoded(SubPacket)
    case encrypted(Data)

  #if !swift(>=4.1)
    static func ==(lhs: MeshPacket.OneOf_Payload, rhs: MeshPacket.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.decoded, .decoded): return {
        guard case .decoded(let l) = lhs, case .decoded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.encrypted, .encrypted): return {
        guard case .encrypted(let l) = lhs, case .encrypted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Full settings (center freq, spread factor, pre-shared secret key etc...)
/// needed to configure a radio for speaking on a particlar channel This
/// information can be encoded as a QRcode/url so that other users can configure
/// their radio to join the same channel.
/// A note aboute how channel names are shown to users: channelname-Xy
/// poundsymbol is a prefix used to indicate this is a channel name (idea from @professr).
/// Where X is a letter from A-Z (base 26) representing a hash of the PSK for this
/// channel - so that if the user changes anything about the channel (which does
/// force a new PSK) this letter will also change. Thus preventing user confusion if
/// two friends try to type in a channel name of "BobsChan" and then can't talk
/// because their PSKs will be different.  The PSK is hashed into this letter by
/// "0x41 + [xor all bytes of the psk ] modulo 26"
/// This also allows the option of someday if people have the PSK off (zero), the
/// users COULD type in a channel name and be able to talk.
/// Y is a lower case letter from a-z that represents the channel 'speed' settings
/// (for some future definition of speed)
/// 
/// FIXME: Add description of multi-channel support and how primary vs secondary channels are used.
/// FIXME: explain how apps use channels for security.  explain how remote settings and 
/// remote gpio are managed as an example
struct ChannelSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// If zero then, use default max legal continuous power (ie. something that won't
  /// burn out the radio hardware)
  /// In most cases you should use zero here.
  var txPower: Int32 = 0

  ///
  /// Note: This is the 'old' mechanism for specifying channel parameters.
  /// Either modem_config or bandwidth/spreading/coding will be specified - NOT
  /// BOTH. As a heuristic: If bandwidth is specified, do not use modem_config.
  /// Because protobufs take ZERO space when the value is zero this works out
  /// nicely.
  /// This value is replaced by bandwidth/spread_factor/coding_rate.  If you'd
  /// like to experiment with other options add them to MeshRadio.cpp in the
  /// device code.
  var modemConfig: ChannelSettings.ModemConfig = .bw125Cr45Sf128

  ///
  /// Bandwidth in MHz
  /// Certain bandwidth numbers are 'special' and will be converted to the
  /// appropriate floating point value: 31 -> 31.25MHz
  var bandwidth: UInt32 = 0

  ///
  /// A number from 7 to 12.  Indicates number of chirps per symbol as
  /// 1<<spread_factor.
  var spreadFactor: UInt32 = 0

  ///
  /// The denominator of the coding rate.  ie for 4/8, the value is 8. 5/8 the value is 5.
  var codingRate: UInt32 = 0

  ///
  /// A channel number between 1 and 13 (or whatever the max is in the current
  /// region). If ZERO then the rule is "use the old channel name hash based
  /// algoritm to derive the channel number")
  /// If using the hash algorithm the channel number will be: hash(channel_name) %
  /// NUM_CHANNELS (Where num channels depends on the regulatory region).
  /// NUM_CHANNELS_US is 13, for other values see MeshRadio.h in the device code.
  /// hash a string into an integer - djb2 by Dan Bernstein. -
  /// http://www.cse.yorku.ca/~oz/hash.html
  /// unsigned long hash(char *str) {
  ///   unsigned long hash = 5381; int c;
  ///   while ((c = *str++) != 0)
  ///     hash = ((hash << 5) + hash) + (unsigned char) c;
  ///   return hash;
  /// }
  var channelNum: UInt32 = 0

  ///
  /// A simple preshared key for now for crypto.  Must be either 0 bytes (no
  /// crypto), 16 bytes (AES128), or 32 bytes (AES256)
  /// A special shorthand is used for 1 byte long psks.  These psks should be treated as only minimally secure,
  /// because they are listed in this source code.  Those bytes are mapped using the following scheme:
  /// 0 = No crypto
  /// 1 = The special default channel key: {0xd4, 0xf1, 0xbb, 0x3a, 0x20, 0x29, 0x07, 0x59, 0xf0, 0xbc, 0xff, 0xab, 0xcf, 0x4e, 0x69, 0xbf}
  /// 2 through 10 = The default channel key, except with 1 through 9 added to the last byte
  var psk: Data = Data()

  ///
  /// A SHORT name that will be packed into the URL.  Less than 12 bytes.
  /// Something for end users to call the channel
  /// If this is the empty string it is assumed that this channel is the special (minimially secure) "Default"
  /// channel.  In user interfaces it should be rendered as a local language translation of "X".  For channel_num
  /// hashing empty string will be treated as "X".
  /// Where "X" is selected based on the english words listed above for ModemConfig
  var name: String = String()

  ///
  /// Used to construct a globally unique channel ID.  The full globally unique ID will be: "name.id"
  /// where ID is shown as base36.  Assuming that the number of meshtastic users is below 20K (true for a long time)
  /// the chance of this 64 bit random number colliding with anyone else is super low.  And the penalty for
  /// collision is low as well, it just means that anyone trying to decrypt channel messages might need to
  /// try multiple candidate channels.
  /// Any time a non wire compatible change is made to a channel, this field should be regenerated.
  /// There are a small number of 'special' globally known (and fairly) insecure standard channels.  
  /// Those channels do not have a numeric id included in the settings, but instead it is pulled from
  /// a table of well known IDs.  (see Well Known Channels FIXME)
  var id: UInt32 = 0

  ///
  /// If true, messages on the mesh will be sent to the *public* internet by any gateway ndoe
  var uplinkEnabled: Bool = false

  ///
  /// If true, messages seen on the internet will be forwarded to the local mesh.
  var downlinkEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Standard predefined channel settings 
  /// Note: these mappings must match ModemConfigChoice in the device code.
  enum ModemConfig: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// < Bw = 125 kHz, Cr = 4/5, Sf(7) = 128chips/symbol, CRC
    /// < on. Default medium range (5.469 kbps)
    case bw125Cr45Sf128 // = 0

    ///
    /// < Bw = 500 kHz, Cr = 4/5, Sf(7) = 128chips/symbol, CRC
    /// < on. Fast+short range (21.875 kbps)
    case bw500Cr45Sf128 // = 1

    ///
    /// < Bw = 31.25 kHz, Cr = 4/8, Sf(9) = 512chips/symbol,
    /// < CRC on. Slow+long range (275 bps)
    case bw3125Cr48Sf512 // = 2

    ///
    /// < Bw = 125 kHz, Cr = 4/8, Sf(12) = 4096chips/symbol, CRC
    /// < on. Slow+long range (183 bps)
    case bw125Cr48Sf4096 // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .bw125Cr45Sf128
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .bw125Cr45Sf128
      case 1: self = .bw500Cr45Sf128
      case 2: self = .bw3125Cr48Sf512
      case 3: self = .bw125Cr48Sf4096
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .bw125Cr45Sf128: return 0
      case .bw500Cr45Sf128: return 1
      case .bw3125Cr48Sf512: return 2
      case .bw125Cr48Sf4096: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ChannelSettings.ModemConfig: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ChannelSettings.ModemConfig] = [
    .bw125Cr45Sf128,
    .bw500Cr45Sf128,
    .bw3125Cr48Sf512,
    .bw125Cr48Sf4096,
  ]
}

#endif  // swift(>=4.2)

///
/// The entire set of user settable/readable settings for our radio device.
/// Includes both the current channel settings and any preferences the user has
/// set for behavior of their node
struct RadioConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var preferences: RadioConfig.UserPreferences {
    get {return _preferences ?? RadioConfig.UserPreferences()}
    set {_preferences = newValue}
  }
  /// Returns true if `preferences` has been explicitly set.
  var hasPreferences: Bool {return self._preferences != nil}
  /// Clears the value of `preferences`. Subsequent reads from it will return its default value.
  mutating func clearPreferences() {self._preferences = nil}

  ///
  /// The preferred way to find channel settings is now in FromRadio. 
  var channelSettings: ChannelSettings {
    get {return _channelSettings ?? ChannelSettings()}
    set {_channelSettings = newValue}
  }
  /// Returns true if `channelSettings` has been explicitly set.
  var hasChannelSettings: Bool {return self._channelSettings != nil}
  /// Clears the value of `channelSettings`. Subsequent reads from it will return its default value.
  mutating func clearChannelSettings() {self._channelSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// see sw-design.md for more information on these preferences
  struct UserPreferences {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// We should send our position this often (but only if it has changed significantly)
    /// Defaults to 15 minutes
    var positionBroadcastSecs: UInt32 {
      get {return _storage._positionBroadcastSecs}
      set {_uniqueStorage()._positionBroadcastSecs = newValue}
    }

    ///
    /// Send our owner info at least this often (also we always send once at boot - to rejoin the mesh)
    var sendOwnerInterval: UInt32 {
      get {return _storage._sendOwnerInterval}
      set {_uniqueStorage()._sendOwnerInterval = newValue}
    }

    ///
    /// Power management state machine option.
    /// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
    /// 0 for default of 1 minute
    var waitBluetoothSecs: UInt32 {
      get {return _storage._waitBluetoothSecs}
      set {_uniqueStorage()._waitBluetoothSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
    /// 0 for default of one minute
    var screenOnSecs: UInt32 {
      get {return _storage._screenOnSecs}
      set {_uniqueStorage()._screenOnSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
    /// 0 for default of 15 minutes
    var phoneTimeoutSecs: UInt32 {
      get {return _storage._phoneTimeoutSecs}
      set {_uniqueStorage()._phoneTimeoutSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
    /// 0 for default of two hours, MAXUINT for disabled
    var phoneSdsTimeoutSec: UInt32 {
      get {return _storage._phoneSdsTimeoutSec}
      set {_uniqueStorage()._phoneSdsTimeoutSec = newValue}
    }

    ///
    /// Power management state machine option.
    /// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
    /// 0 for default of two hours, MAXUINT for disabled
    var meshSdsTimeoutSecs: UInt32 {
      get {return _storage._meshSdsTimeoutSecs}
      set {_uniqueStorage()._meshSdsTimeoutSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
    /// 0 for default of one year
    var sdsSecs: UInt32 {
      get {return _storage._sdsSecs}
      set {_uniqueStorage()._sdsSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
    /// 0 for default of 3600
    var lsSecs: UInt32 {
      get {return _storage._lsSecs}
      set {_uniqueStorage()._lsSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See https://github.com/meshtastic/Meshtastic-device/blob/master/docs/software/power.md for details.
    /// 0 for default of 10 seconds
    var minWakeSecs: UInt32 {
      get {return _storage._minWakeSecs}
      set {_uniqueStorage()._minWakeSecs = newValue}
    }

    /// If set, this node will try to join the specified wifi network and
    /// acquire an address via DHCP
    var wifiSsid: String {
      get {return _storage._wifiSsid}
      set {_uniqueStorage()._wifiSsid = newValue}
    }

    ///
    /// If set, will be use to authenticate to the named wifi
    var wifiPassword: String {
      get {return _storage._wifiPassword}
      set {_uniqueStorage()._wifiPassword = newValue}
    }

    ///
    /// If set, the node will operate as an AP (and DHCP server), otherwise it
    /// will be a station
    var wifiApMode: Bool {
      get {return _storage._wifiApMode}
      set {_uniqueStorage()._wifiApMode = newValue}
    }

    ///
    /// The region code for my radio (US, CN, EU433, etc...)
    var region: RegionCode {
      get {return _storage._region}
      set {_uniqueStorage()._region = newValue}
    }

    ///
    /// Sets the current of the battery charger
    var chargeCurrent: ChargeCurrent {
      get {return _storage._chargeCurrent}
      set {_uniqueStorage()._chargeCurrent = newValue}
    }

    ///
    /// Are we operating as a router.  Changes behavior in the following ways:
    /// The device will only sleep for critically low battery level (i.e. always tries to stay alive for the mesh)
    /// In the future routing decisions will preferentially route packets through nodes with this attribute (because assumed
    /// good line of sight)
    var isRouter: Bool {
      get {return _storage._isRouter}
      set {_uniqueStorage()._isRouter = newValue}
    }

    ///
    /// If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
    /// we should try to minimize power consumption as much as possible.  YOU DO NOT NEED TO SET THIS IF YOU'VE
    /// set is_router (it is implied in that case).
    var isLowPower: Bool {
      get {return _storage._isLowPower}
      set {_uniqueStorage()._isLowPower = newValue}
    }

    ///
    /// If set, this node is at a fixed position.  We will generate GPS position updates
    /// at the regular interval, but use whatever the last lat/lon/alt we have for the node.
    /// The lat/lon/alt can be set by an internal GPS or with the help of the app.
    var fixedPosition: Bool {
      get {return _storage._fixedPosition}
      set {_uniqueStorage()._fixedPosition = newValue}
    }

    ///
    /// This setting is never saved to disk, but if set, all device settings will be
    /// returned to factory defaults.  (Region, serial number etc... will be preserved)
    var factoryReset: Bool {
      get {return _storage._factoryReset}
      set {_uniqueStorage()._factoryReset = newValue}
    }

    ///
    /// By default we turn off logging as soon as an API client connects (to keep
    /// shared serial link quiet).  Set this to true to leave the debug log outputting even when API is active.
    var debugLogEnabled: Bool {
      get {return _storage._debugLogEnabled}
      set {_uniqueStorage()._debugLogEnabled = newValue}
    }

    ///*
    ///How our location is shared with other nodes (or the local phone)
    var locationShare: LocationSharing {
      get {return _storage._locationShare}
      set {_uniqueStorage()._locationShare = newValue}
    }

    ///
    /// How the GPS hardware in this unit is operated.
    /// Note: This is independent of how our location is shared with other devices.  For that see LocationSharing
    var gpsOperation: GpsOperation {
      get {return _storage._gpsOperation}
      set {_uniqueStorage()._gpsOperation = newValue}
    }

    ///
    /// How often should we try to get GPS position (in seconds) when we are in GpsOpMobile mode?
    /// or zero for the default of once every 30 seconds
    /// or a very large value (maxint) to update only once at boot.
    var gpsUpdateInterval: UInt32 {
      get {return _storage._gpsUpdateInterval}
      set {_uniqueStorage()._gpsUpdateInterval = newValue}
    }

    ///
    /// How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
    /// Or if zero, use the default of 30 seconds.
    /// If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
    /// window. 
    var gpsAttemptTime: UInt32 {
      get {return _storage._gpsAttemptTime}
      set {_uniqueStorage()._gpsAttemptTime = newValue}
    }

    ///
    /// If true, radio should not try to be smart about what packets to queue to
    /// the phone
    /// bool keep_all_packets = 101;
    ///
    /// If true, we will try to capture all the packets sent on the mesh, not
    /// just the ones destined to our node.
    /// bool promiscuous_mode = 102;
    ///
    /// For testing it is useful sometimes to force a node to never listen to
    /// particular other nodes (simulating radio out of range). All nodenums listed
    /// in ignore_incoming will have packets they send droped on receive (by router.cpp)
    var ignoreIncoming: [UInt32] {
      get {return _storage._ignoreIncoming}
      set {_uniqueStorage()._ignoreIncoming = newValue}
    }

    ///*
    ///Preferences for the SerialPlugin
    ///
    ///FIXME - Move this out of UserPreferences and into a section for plugin configuration.
    var serialpluginEnabled: Bool {
      get {return _storage._serialpluginEnabled}
      set {_uniqueStorage()._serialpluginEnabled = newValue}
    }

    var serialpluginEcho: Bool {
      get {return _storage._serialpluginEcho}
      set {_uniqueStorage()._serialpluginEcho = newValue}
    }

    var serialpluginRxd: UInt32 {
      get {return _storage._serialpluginRxd}
      set {_uniqueStorage()._serialpluginRxd = newValue}
    }

    var serialpluginTxd: UInt32 {
      get {return _storage._serialpluginTxd}
      set {_uniqueStorage()._serialpluginTxd = newValue}
    }

    var serialpluginTimeout: UInt32 {
      get {return _storage._serialpluginTimeout}
      set {_uniqueStorage()._serialpluginTimeout = newValue}
    }

    var serialpluginMode: UInt32 {
      get {return _storage._serialpluginMode}
      set {_uniqueStorage()._serialpluginMode = newValue}
    }

    ///*
    ///Preferences for the ExternalNotificationPlugin
    ///
    ///FIXME - Move this out of UserPreferences and into a section for plugin configuration.
    var extNotificationPluginEnabled: Bool {
      get {return _storage._extNotificationPluginEnabled}
      set {_uniqueStorage()._extNotificationPluginEnabled = newValue}
    }

    var extNotificationPluginOutputMs: UInt32 {
      get {return _storage._extNotificationPluginOutputMs}
      set {_uniqueStorage()._extNotificationPluginOutputMs = newValue}
    }

    var extNotificationPluginOutput: UInt32 {
      get {return _storage._extNotificationPluginOutput}
      set {_uniqueStorage()._extNotificationPluginOutput = newValue}
    }

    var extNotificationPluginActive: Bool {
      get {return _storage._extNotificationPluginActive}
      set {_uniqueStorage()._extNotificationPluginActive = newValue}
    }

    var extNotificationPluginAlertMessage: Bool {
      get {return _storage._extNotificationPluginAlertMessage}
      set {_uniqueStorage()._extNotificationPluginAlertMessage = newValue}
    }

    var extNotificationPluginAlertBell: Bool {
      get {return _storage._extNotificationPluginAlertBell}
      set {_uniqueStorage()._extNotificationPluginAlertBell = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _preferences: RadioConfig.UserPreferences? = nil
  fileprivate var _channelSettings: ChannelSettings? = nil
}

///
/// The bluetooth to device link:
///
/// Old BTLE protocol docs from TODO, merge in above and make real docs...
///
/// use protocol buffers, and NanoPB
///
/// messages from device to phone:
/// POSITION_UPDATE (..., time)
/// TEXT_RECEIVED(from, text, time)
/// OPAQUE_RECEIVED(from, payload, time) (for signal messages or other applications)
///
/// messages from phone to device:
/// SET_MYID(id, human readable long, human readable short) (send down the unique ID
/// string used for this node, a human readable string shown for that id, and a very
/// short human readable string suitable for oled screen) SEND_OPAQUE(dest, payload)
/// (for signal messages or other applications) SEND_TEXT(dest, text) Get all
/// nodes() (returns list of nodes, with full info, last time seen, loc, battery
/// level etc) SET_CONFIG (switches device to a new set of radio params and
/// preshared key, drops all existing nodes, force our node to rejoin this new group)
///
/// Full information about a node on the mesh
struct NodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// the node number
  var num: UInt32 = 0

  ///
  /// The user info for this node
  var user: User {
    get {return _user ?? User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  ///
  /// This position data will also contain a time last seen
  var position: Position {
    get {return _position ?? Position()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  ///
  /// Returns the Signal-to-noise ratio (SNR) of the last received message, as measured by the receiver.
  /// Return SNR of the last received message in dB
  var snr: Float = 0

  ///
  /// Returns the last measured frequency error.
  /// The LoRa receiver estimates the frequency offset between the receiver
  /// centre frequency and that of the received LoRa signal. This function
  /// returns the estimates offset (in Hz) of the last received message.
  /// Caution: this measurement is not absolute, but is measured relative to the
  /// local receiver's oscillator. Apparent errors may be due to the
  /// transmitter, the receiver or both. \return The estimated centre frequency
  /// offset in Hz of the last received message.
  /// int32 frequency_error = 6;
  ///
  /// enum RouteState {
  ///  Invalid = 0;
  ///  Discovering = 1;
  ///  Valid = 2;
  /// }
  /// 
  /// Not needed?
  /// RouteState route = 4;
  /// 
  /// Our current preferred node node for routing - might be the same as num if
  /// we are adjacent Or zero if we don't yet know a route to this node.
  var nextHop: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _user: User? = nil
  fileprivate var _position: Position? = nil
}

///
/// Unique local debugging info for this node
/// Note: we don't include position or the user info, because that will come in the
/// Sent to the phone in response to WantNodes.
struct MyNodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// Tells the phone what our node number is, default starting value is lowbyte of macaddr, but it will be fixed if that is already in use
  var myNodeNum: UInt32 = 0

  ///
  /// Note: this bool no longer means "we have our own GPS".  Because gps_operation is more advanced,
  /// but we'd like old phone apps to keep working.  So for legacy reasons we set this flag as follows:  
  /// if false it would be great if the phone can help provide gps coordinates.  If true we don't need location
  /// assistance from the phone.
  var hasGps_p: Bool = false

  ///
  /// # of legal channels (set at build time in the device flash image)
  var numChannels: Int32 = 0

  ///
  /// The region code for my radio (US, CN, etc...)
  /// Note: This string is deprecated.  The 1.0 builds populate it based on the
  /// flashed firmware name.  But for newer builds this string will be unpopulated
  /// (missing/null).  For those builds you should instead look at the new
  /// read/write region enum in UserSettings   
  /// The format of this string was 1.0-US or 1.0-CN etc.. Or empty string if unset.
  var region: String = String()

  ///
  /// TBEAM, HELTEC, etc...
  var hwModel: String = String()

  ///
  /// 0.0.5 etc...
  var firmwareVersion: String = String()

  ///
  /// An error message we'd like to report back to the mothership through analytics.
  /// It indicates a serious bug occurred on the device, the device coped with it, but we still want to tell the devs about the bug.
  /// This field will be cleared after the phone reads MyNodeInfo (i.e. it will onlybe reported once)
  /// a numeric error code to go with error message, zero means no error
  var errorCode: CriticalErrorCode = .none

  ///
  /// A numeric error address (nonzero if available)
  var errorAddress: UInt32 = 0

  ///
  /// The total number of errors this node has ever encountered (well - since the last time we discarded preferences)
  var errorCount: UInt32 = 0

  ///
  /// How many bits are used for the packetid.  If zero it is assumed we use
  /// eight bit packetids Old device loads (older that 0.6.5 do not populate this field, but all newer loads do).
  var packetIDBits: UInt32 = 0

  ///
  /// The current ID this node is using for sending new packets (exposed so that
  /// the phone can self assign packet IDs if it wishes by picking packet IDs from
  /// the opposite side of the pacekt ID space).
  /// Old device loads (older that 0.6.5 do not populate this field, but all newer loads do).
  /// FIXME: that we need to expose this is a bit of a mistake.  Really the phones
  /// should be modeled/treated as 1st class nodes like any other, and the radio
  /// connected to the phone just routes like any other. This would allow all sorts
  /// of clean/clever routing topologies in the future.
  var currentPacketID: UInt32 = 0

  ///
  /// How many bits are used for the nodenum.  If zero it is assumed we use
  /// eight bit nodenums New device loads will user 32 bit nodenum.
  /// Old device loads (older that 0.6.5 do not populate this field, but all newer
  /// loads do).
  var nodeNumBits: UInt32 = 0

  ///
  /// How long before we consider a message abandoned and we can clear our
  /// caches of any messages in flight Normally quite large to handle the worst case
  /// message delivery time, 5 minutes.  Formerly called FLOOD_EXPIRE_TIME in the
  /// device code
  var messageTimeoutMsec: UInt32 = 0

  ///
  /// The minimum app version that can talk to this device.  Phone/PC apps should
  /// compare this to their build number and if too low tell the user they must
  /// update their app
  var minAppVersion: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Debug output from the device.
///
/// To minimize the size of records inside the device code, if a time/source/level is not set 
/// on the message it is assumed to be a contuinuation of the previously sent message.  This allows
/// the device code to use fixed maxlen 64 byte strings for messages, and then extend as needed by
/// emitting multiple records.
struct LogRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  ///
  /// Seconds since 1970 - or 0 for unknown/unset
  var time: UInt32 = 0

  ///
  /// Usually based on thread name - if known
  var source: String = String()

  ///
  /// Not yet set
  var level: LogRecord.Level = .unset

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// Log levels, chosen to match python logging conventions.
  enum Level: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unset // = 0
    case critical // = 50
    case error // = 40
    case warning // = 30
    case info // = 20
    case debug // = 10
    case trace // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unset
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 5: self = .trace
      case 10: self = .debug
      case 20: self = .info
      case 30: self = .warning
      case 40: self = .error
      case 50: self = .critical
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unset: return 0
      case .trace: return 5
      case .debug: return 10
      case .info: return 20
      case .warning: return 30
      case .error: return 40
      case .critical: return 50
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension LogRecord.Level: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [LogRecord.Level] = [
    .unset,
    .critical,
    .error,
    .warning,
    .info,
    .debug,
    .trace,
  ]
}

#endif  // swift(>=4.2)

///
/// Packets from the radio to the phone will appear on the fromRadio characteristic.
/// It will support READ and NOTIFY. When a new packet arrives the device will BLE notify?
/// It will sit in that descriptor until consumed by the phone, at which point the next item in the FIFO will be populated.
struct FromRadio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// The packet num, used to allow the phone to request missing read packets from the FIFO, see our bluetooth docs
  var num: UInt32 = 0

  var variant: FromRadio.OneOf_Variant? = nil

  var packet: MeshPacket {
    get {
      if case .packet(let v)? = variant {return v}
      return MeshPacket()
    }
    set {variant = .packet(newValue)}
  }

  ///
  /// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
  var myInfo: MyNodeInfo {
    get {
      if case .myInfo(let v)? = variant {return v}
      return MyNodeInfo()
    }
    set {variant = .myInfo(newValue)}
  }

  ///
  /// One packet is sent for each node in the on radio DB
  /// starts over with the first node in our DB
  var nodeInfo: NodeInfo {
    get {
      if case .nodeInfo(let v)? = variant {return v}
      return NodeInfo()
    }
    set {variant = .nodeInfo(newValue)}
  }

  ///
  /// In rev1 this was the radio BLE characteristic
  var radio: RadioConfig {
    get {
      if case .radio(let v)? = variant {return v}
      return RadioConfig()
    }
    set {variant = .radio(newValue)}
  }

  ///
  /// set to send debug console output over our protobuf stream
  var logRecord: LogRecord {
    get {
      if case .logRecord(let v)? = variant {return v}
      return LogRecord()
    }
    set {variant = .logRecord(newValue)}
  }

  ///
  /// sent as true once the device has finished sending all of the responses to want_config
  /// recipient should check if this ID matches our original request nonce, if
  /// not, it means your config responses haven't started yet.
  var configCompleteID: UInt32 {
    get {
      if case .configCompleteID(let v)? = variant {return v}
      return 0
    }
    set {variant = .configCompleteID(newValue)}
  }

  ///
  /// Sent to tell clients the radio has just rebooted.  Set to true if present.
  /// Not used on all transports, currently just used for the serial console.
  var rebooted: Bool {
    get {
      if case .rebooted(let v)? = variant {return v}
      return false
    }
    set {variant = .rebooted(newValue)}
  }

  ///
  /// One of the channels, they are all sent during config download
  /// The first channel is the "primary" channel all other channels are secondary channels
  /// The primary channel is also sent as part of RadioConfig (which is deprecated, but to support older clients)
  var channel: ChannelSettings {
    get {
      if case .channel(let v)? = variant {return v}
      return ChannelSettings()
    }
    set {variant = .channel(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Variant: Equatable {
    case packet(MeshPacket)
    ///
    /// Tells the phone what our node number is, can be -1 if we've not yet joined a mesh.
    case myInfo(MyNodeInfo)
    ///
    /// One packet is sent for each node in the on radio DB
    /// starts over with the first node in our DB
    case nodeInfo(NodeInfo)
    ///
    /// In rev1 this was the radio BLE characteristic
    case radio(RadioConfig)
    ///
    /// set to send debug console output over our protobuf stream
    case logRecord(LogRecord)
    ///
    /// sent as true once the device has finished sending all of the responses to want_config
    /// recipient should check if this ID matches our original request nonce, if
    /// not, it means your config responses haven't started yet.
    case configCompleteID(UInt32)
    ///
    /// Sent to tell clients the radio has just rebooted.  Set to true if present.
    /// Not used on all transports, currently just used for the serial console.
    case rebooted(Bool)
    ///
    /// One of the channels, they are all sent during config download
    /// The first channel is the "primary" channel all other channels are secondary channels
    /// The primary channel is also sent as part of RadioConfig (which is deprecated, but to support older clients)
    case channel(ChannelSettings)

  #if !swift(>=4.1)
    static func ==(lhs: FromRadio.OneOf_Variant, rhs: FromRadio.OneOf_Variant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.packet, .packet): return {
        guard case .packet(let l) = lhs, case .packet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.myInfo, .myInfo): return {
        guard case .myInfo(let l) = lhs, case .myInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nodeInfo, .nodeInfo): return {
        guard case .nodeInfo(let l) = lhs, case .nodeInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.radio, .radio): return {
        guard case .radio(let l) = lhs, case .radio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.logRecord, .logRecord): return {
        guard case .logRecord(let l) = lhs, case .logRecord(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configCompleteID, .configCompleteID): return {
        guard case .configCompleteID(let l) = lhs, case .configCompleteID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rebooted, .rebooted): return {
        guard case .rebooted(let l) = lhs, case .rebooted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channel, .channel): return {
        guard case .channel(let l) = lhs, case .channel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

///
/// packets/commands to the radio will be written (reliably) to the toRadio characteristic.
/// Once the write completes the phone can assume it is handled.
struct ToRadio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var variant: ToRadio.OneOf_Variant? = nil

  ///
  /// send this packet on the mesh
  var packet: MeshPacket {
    get {
      if case .packet(let v)? = variant {return v}
      return MeshPacket()
    }
    set {variant = .packet(newValue)}
  }

  ///
  /// phone wants radio to send full node db to the phone, This is
  /// typically the first packet sent to the radio when the phone gets a
  /// bluetooth connection. The radio will respond by sending back a
  /// MyNodeInfo, a owner, a radio config and a series of
  /// FromRadio.node_infos, and config_complete
  /// the integer you write into this field will be reported back in the
  /// config_complete_id response this allows clients to never be confused by
  /// a stale old partially sent config.
  var wantConfigID: UInt32 {
    get {
      if case .wantConfigID(let v)? = variant {return v}
      return 0
    }
    set {variant = .wantConfigID(newValue)}
  }

  ///
  /// set the radio provisioning for this node
  var setRadio: RadioConfig {
    get {
      if case .setRadio(let v)? = variant {return v}
      return RadioConfig()
    }
    set {variant = .setRadio(newValue)}
  }

  ///
  /// Set the owner for this node
  var setOwner: User {
    get {
      if case .setOwner(let v)? = variant {return v}
      return User()
    }
    set {variant = .setOwner(newValue)}
  }

  ///
  /// Set channels (using the new API).  The first sent channel is assumed to be channel
  /// index 0 the "primary channel".  Following records are secondary channels.
  var setChannel: ChannelSettings {
    get {
      if case .setChannel(let v)? = variant {return v}
      return ChannelSettings()
    }
    set {variant = .setChannel(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Variant: Equatable {
    ///
    /// send this packet on the mesh
    case packet(MeshPacket)
    ///
    /// phone wants radio to send full node db to the phone, This is
    /// typically the first packet sent to the radio when the phone gets a
    /// bluetooth connection. The radio will respond by sending back a
    /// MyNodeInfo, a owner, a radio config and a series of
    /// FromRadio.node_infos, and config_complete
    /// the integer you write into this field will be reported back in the
    /// config_complete_id response this allows clients to never be confused by
    /// a stale old partially sent config.
    case wantConfigID(UInt32)
    ///
    /// set the radio provisioning for this node
    case setRadio(RadioConfig)
    ///
    /// Set the owner for this node
    case setOwner(User)
    ///
    /// Set channels (using the new API).  The first sent channel is assumed to be channel
    /// index 0 the "primary channel".  Following records are secondary channels.
    case setChannel(ChannelSettings)

  #if !swift(>=4.1)
    static func ==(lhs: ToRadio.OneOf_Variant, rhs: ToRadio.OneOf_Variant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.packet, .packet): return {
        guard case .packet(let l) = lhs, case .packet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wantConfigID, .wantConfigID): return {
        guard case .wantConfigID(let l) = lhs, case .wantConfigID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setRadio, .setRadio): return {
        guard case .setRadio(let l) = lhs, case .setRadio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setOwner, .setOwner): return {
        guard case .setOwner(let l) = lhs, case .setOwner(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setChannel, .setChannel): return {
        guard case .setChannel(let l) = lhs, case .setChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension RouteError: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "NO_ROUTE"),
    2: .same(proto: "GOT_NAK"),
    3: .same(proto: "TIMEOUT"),
  ]
}

extension Constants: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unused"),
    240: .same(proto: "DATA_PAYLOAD_LEN"),
  ]
}

extension RegionCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unset"),
    1: .same(proto: "US"),
    2: .same(proto: "EU433"),
    3: .same(proto: "EU865"),
    4: .same(proto: "CN"),
    5: .same(proto: "JP"),
    6: .same(proto: "ANZ"),
    7: .same(proto: "KR"),
    8: .same(proto: "TW"),
  ]
}

extension ChargeCurrent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAUnset"),
    1: .same(proto: "MA100"),
    2: .same(proto: "MA190"),
    3: .same(proto: "MA280"),
    4: .same(proto: "MA360"),
    5: .same(proto: "MA450"),
    6: .same(proto: "MA550"),
    7: .same(proto: "MA630"),
    8: .same(proto: "MA700"),
    9: .same(proto: "MA780"),
    10: .same(proto: "MA880"),
    11: .same(proto: "MA960"),
    12: .same(proto: "MA1000"),
    13: .same(proto: "MA1080"),
    14: .same(proto: "MA1160"),
    15: .same(proto: "MA1240"),
    16: .same(proto: "MA1320"),
  ]
}

extension GpsOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GpsOpUnset"),
    1: .same(proto: "GpsOpStationary"),
    2: .same(proto: "GpsOpMobile"),
    3: .same(proto: "GpsOpTimeOnly"),
    4: .same(proto: "GpsOpDisabled"),
  ]
}

extension LocationSharing: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LocUnset"),
    1: .same(proto: "LocEnabled"),
    2: .same(proto: "LocDisabled"),
  ]
}

extension CriticalErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "TxWatchdog"),
    2: .same(proto: "SleepEnterWait"),
    3: .same(proto: "NoRadio"),
    4: .same(proto: "Unspecified"),
    5: .same(proto: "UBloxInitFailed"),
    6: .same(proto: "NoAXP192"),
    7: .same(proto: "InvalidRadioSetting"),
    8: .same(proto: "TransmitFailed"),
  ]
}

extension Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Position"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .standard(proto: "latitude_i"),
    8: .standard(proto: "longitude_i"),
    3: .same(proto: "altitude"),
    4: .standard(proto: "battery_level"),
    9: .same(proto: "time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.altitude) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.batteryLevel) }()
      case 7: try { try decoder.decodeSingularSInt32Field(value: &self.latitudeI) }()
      case 8: try { try decoder.decodeSingularSInt32Field(value: &self.longitudeI) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self.time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.altitude != 0 {
      try visitor.visitSingularInt32Field(value: self.altitude, fieldNumber: 3)
    }
    if self.batteryLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.batteryLevel, fieldNumber: 4)
    }
    if self.latitudeI != 0 {
      try visitor.visitSingularSInt32Field(value: self.latitudeI, fieldNumber: 7)
    }
    if self.longitudeI != 0 {
      try visitor.visitSingularSInt32Field(value: self.longitudeI, fieldNumber: 8)
    }
    if self.time != 0 {
      try visitor.visitSingularFixed32Field(value: self.time, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Position, rhs: Position) -> Bool {
    if lhs.latitudeI != rhs.latitudeI {return false}
    if lhs.longitudeI != rhs.longitudeI {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.batteryLevel != rhs.batteryLevel {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "portnum"),
    2: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.portnum) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.portnum != .unknownApp {
      try visitor.visitSingularEnumField(value: self.portnum, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DataMessage, rhs: DataMessage) -> Bool {
    if lhs.portnum != rhs.portnum {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "long_name"),
    3: .standard(proto: "short_name"),
    4: .same(proto: "macaddr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.longName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.shortName) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.macaddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.longName.isEmpty {
      try visitor.visitSingularStringField(value: self.longName, fieldNumber: 2)
    }
    if !self.shortName.isEmpty {
      try visitor.visitSingularStringField(value: self.shortName, fieldNumber: 3)
    }
    if !self.macaddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.macaddr, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: User, rhs: User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.longName != rhs.longName {return false}
    if lhs.shortName != rhs.shortName {return false}
    if lhs.macaddr != rhs.macaddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RouteDiscovery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RouteDiscovery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.route) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.route.isEmpty {
      try visitor.visitPackedInt32Field(value: self.route, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RouteDiscovery, rhs: RouteDiscovery) -> Bool {
    if lhs.route != rhs.route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "data"),
    6: .standard(proto: "route_request"),
    7: .standard(proto: "route_reply"),
    13: .standard(proto: "route_error"),
    1: .same(proto: "position"),
    4: .same(proto: "user"),
    5: .standard(proto: "want_response"),
    10: .standard(proto: "success_id"),
    11: .standard(proto: "fail_id"),
    9: .same(proto: "dest"),
    12: .same(proto: "source"),
    2: .standard(proto: "original_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Position?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .position(v)}
      }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.originalID) }()
      case 3: try {
        var v: DataMessage?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .data(v)}
      }()
      case 4: try {
        var v: User?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .user(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .user(v)}
      }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.wantResponse) }()
      case 6: try {
        var v: RouteDiscovery?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .routeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .routeRequest(v)}
      }()
      case 7: try {
        var v: RouteDiscovery?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .routeReply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .routeReply(v)}
      }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.dest) }()
      case 10: try {
        if self.ack != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.ack = .successID(v)}
      }()
      case 11: try {
        if self.ack != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.ack = .failID(v)}
      }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.source) }()
      case 13: try {
        if self.payload != nil {try decoder.handleConflictingOneOf()}
        var v: RouteError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.payload = .routeError(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .position(let v)? = self.payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.originalID != 0 {
      try visitor.visitSingularUInt32Field(value: self.originalID, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .user?: try {
      guard case .user(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    default: break
    }
    if self.wantResponse != false {
      try visitor.visitSingularBoolField(value: self.wantResponse, fieldNumber: 5)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .routeRequest?: try {
      guard case .routeRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .routeReply?: try {
      guard case .routeReply(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    if self.dest != 0 {
      try visitor.visitSingularUInt32Field(value: self.dest, fieldNumber: 9)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.ack {
    case .successID?: try {
      guard case .successID(let v)? = self.ack else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }()
    case .failID?: try {
      guard case .failID(let v)? = self.ack else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    if self.source != 0 {
      try visitor.visitSingularUInt32Field(value: self.source, fieldNumber: 12)
    }
    if case .routeError(let v)? = self.payload {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubPacket, rhs: SubPacket) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.wantResponse != rhs.wantResponse {return false}
    if lhs.ack != rhs.ack {return false}
    if lhs.dest != rhs.dest {return false}
    if lhs.source != rhs.source {return false}
    if lhs.originalID != rhs.originalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeshPacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MeshPacket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    4: .standard(proto: "channel_index"),
    3: .same(proto: "decoded"),
    8: .same(proto: "encrypted"),
    6: .same(proto: "id"),
    9: .standard(proto: "rx_time"),
    7: .standard(proto: "rx_snr"),
    10: .standard(proto: "hop_limit"),
    11: .standard(proto: "want_ack"),
  ]

  fileprivate class _StorageClass {
    var _from: UInt32 = 0
    var _to: UInt32 = 0
    var _channelIndex: UInt32 = 0
    var _payload: MeshPacket.OneOf_Payload?
    var _id: UInt32 = 0
    var _rxTime: UInt32 = 0
    var _rxSnr: Float = 0
    var _hopLimit: UInt32 = 0
    var _wantAck: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _from = source._from
      _to = source._to
      _channelIndex = source._channelIndex
      _payload = source._payload
      _id = source._id
      _rxTime = source._rxTime
      _rxSnr = source._rxSnr
      _hopLimit = source._hopLimit
      _wantAck = source._wantAck
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._from) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._to) }()
        case 3: try {
          var v: SubPacket?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .decoded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .decoded(v)}
        }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._channelIndex) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._id) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._rxSnr) }()
        case 8: try {
          if _storage._payload != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._payload = .encrypted(v)}
        }()
        case 9: try { try decoder.decodeSingularFixed32Field(value: &_storage._rxTime) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopLimit) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._wantAck) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._from != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._from, fieldNumber: 1)
      }
      if _storage._to != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._to, fieldNumber: 2)
      }
      if case .decoded(let v)? = _storage._payload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._channelIndex != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._channelIndex, fieldNumber: 4)
      }
      if _storage._id != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._id, fieldNumber: 6)
      }
      if _storage._rxSnr != 0 {
        try visitor.visitSingularFloatField(value: _storage._rxSnr, fieldNumber: 7)
      }
      if case .encrypted(let v)? = _storage._payload {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      }
      if _storage._rxTime != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._rxTime, fieldNumber: 9)
      }
      if _storage._hopLimit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hopLimit, fieldNumber: 10)
      }
      if _storage._wantAck != false {
        try visitor.visitSingularBoolField(value: _storage._wantAck, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeshPacket, rhs: MeshPacket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._from != rhs_storage._from {return false}
        if _storage._to != rhs_storage._to {return false}
        if _storage._channelIndex != rhs_storage._channelIndex {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._rxTime != rhs_storage._rxTime {return false}
        if _storage._rxSnr != rhs_storage._rxSnr {return false}
        if _storage._hopLimit != rhs_storage._hopLimit {return false}
        if _storage._wantAck != rhs_storage._wantAck {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChannelSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChannelSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_power"),
    3: .standard(proto: "modem_config"),
    6: .same(proto: "bandwidth"),
    7: .standard(proto: "spread_factor"),
    8: .standard(proto: "coding_rate"),
    9: .standard(proto: "channel_num"),
    4: .same(proto: "psk"),
    5: .same(proto: "name"),
    10: .same(proto: "id"),
    16: .standard(proto: "uplink_enabled"),
    17: .standard(proto: "downlink_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.txPower) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.modemConfig) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.psk) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.bandwidth) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.spreadFactor) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.codingRate) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.channelNum) }()
      case 10: try { try decoder.decodeSingularFixed32Field(value: &self.id) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self.uplinkEnabled) }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.downlinkEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.txPower != 0 {
      try visitor.visitSingularInt32Field(value: self.txPower, fieldNumber: 1)
    }
    if self.modemConfig != .bw125Cr45Sf128 {
      try visitor.visitSingularEnumField(value: self.modemConfig, fieldNumber: 3)
    }
    if !self.psk.isEmpty {
      try visitor.visitSingularBytesField(value: self.psk, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if self.bandwidth != 0 {
      try visitor.visitSingularUInt32Field(value: self.bandwidth, fieldNumber: 6)
    }
    if self.spreadFactor != 0 {
      try visitor.visitSingularUInt32Field(value: self.spreadFactor, fieldNumber: 7)
    }
    if self.codingRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.codingRate, fieldNumber: 8)
    }
    if self.channelNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.channelNum, fieldNumber: 9)
    }
    if self.id != 0 {
      try visitor.visitSingularFixed32Field(value: self.id, fieldNumber: 10)
    }
    if self.uplinkEnabled != false {
      try visitor.visitSingularBoolField(value: self.uplinkEnabled, fieldNumber: 16)
    }
    if self.downlinkEnabled != false {
      try visitor.visitSingularBoolField(value: self.downlinkEnabled, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChannelSettings, rhs: ChannelSettings) -> Bool {
    if lhs.txPower != rhs.txPower {return false}
    if lhs.modemConfig != rhs.modemConfig {return false}
    if lhs.bandwidth != rhs.bandwidth {return false}
    if lhs.spreadFactor != rhs.spreadFactor {return false}
    if lhs.codingRate != rhs.codingRate {return false}
    if lhs.channelNum != rhs.channelNum {return false}
    if lhs.psk != rhs.psk {return false}
    if lhs.name != rhs.name {return false}
    if lhs.id != rhs.id {return false}
    if lhs.uplinkEnabled != rhs.uplinkEnabled {return false}
    if lhs.downlinkEnabled != rhs.downlinkEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChannelSettings.ModemConfig: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Bw125Cr45Sf128"),
    1: .same(proto: "Bw500Cr45Sf128"),
    2: .same(proto: "Bw31_25Cr48Sf512"),
    3: .same(proto: "Bw125Cr48Sf4096"),
  ]
}

extension RadioConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RadioConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preferences"),
    2: .standard(proto: "channel_settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._preferences) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._channelSettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._preferences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._channelSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RadioConfig, rhs: RadioConfig) -> Bool {
    if lhs._preferences != rhs._preferences {return false}
    if lhs._channelSettings != rhs._channelSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RadioConfig.UserPreferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RadioConfig.protoMessageName + ".UserPreferences"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_broadcast_secs"),
    2: .standard(proto: "send_owner_interval"),
    4: .standard(proto: "wait_bluetooth_secs"),
    5: .standard(proto: "screen_on_secs"),
    6: .standard(proto: "phone_timeout_secs"),
    7: .standard(proto: "phone_sds_timeout_sec"),
    8: .standard(proto: "mesh_sds_timeout_secs"),
    9: .standard(proto: "sds_secs"),
    10: .standard(proto: "ls_secs"),
    11: .standard(proto: "min_wake_secs"),
    12: .standard(proto: "wifi_ssid"),
    13: .standard(proto: "wifi_password"),
    14: .standard(proto: "wifi_ap_mode"),
    15: .same(proto: "region"),
    16: .standard(proto: "charge_current"),
    37: .standard(proto: "is_router"),
    38: .standard(proto: "is_low_power"),
    39: .standard(proto: "fixed_position"),
    100: .standard(proto: "factory_reset"),
    101: .standard(proto: "debug_log_enabled"),
    32: .standard(proto: "location_share"),
    33: .standard(proto: "gps_operation"),
    34: .standard(proto: "gps_update_interval"),
    36: .standard(proto: "gps_attempt_time"),
    103: .standard(proto: "ignore_incoming"),
    120: .standard(proto: "serialplugin_enabled"),
    121: .standard(proto: "serialplugin_echo"),
    122: .standard(proto: "serialplugin_rxd"),
    123: .standard(proto: "serialplugin_txd"),
    124: .standard(proto: "serialplugin_timeout"),
    125: .standard(proto: "serialplugin_mode"),
    126: .standard(proto: "ext_notification_plugin_enabled"),
    127: .standard(proto: "ext_notification_plugin_output_ms"),
    128: .standard(proto: "ext_notification_plugin_output"),
    129: .standard(proto: "ext_notification_plugin_active"),
    130: .standard(proto: "ext_notification_plugin_alert_message"),
    131: .standard(proto: "ext_notification_plugin_alert_bell"),
  ]

  fileprivate class _StorageClass {
    var _positionBroadcastSecs: UInt32 = 0
    var _sendOwnerInterval: UInt32 = 0
    var _waitBluetoothSecs: UInt32 = 0
    var _screenOnSecs: UInt32 = 0
    var _phoneTimeoutSecs: UInt32 = 0
    var _phoneSdsTimeoutSec: UInt32 = 0
    var _meshSdsTimeoutSecs: UInt32 = 0
    var _sdsSecs: UInt32 = 0
    var _lsSecs: UInt32 = 0
    var _minWakeSecs: UInt32 = 0
    var _wifiSsid: String = String()
    var _wifiPassword: String = String()
    var _wifiApMode: Bool = false
    var _region: RegionCode = .unset
    var _chargeCurrent: ChargeCurrent = .maunset
    var _isRouter: Bool = false
    var _isLowPower: Bool = false
    var _fixedPosition: Bool = false
    var _factoryReset: Bool = false
    var _debugLogEnabled: Bool = false
    var _locationShare: LocationSharing = .locUnset
    var _gpsOperation: GpsOperation = .gpsOpUnset
    var _gpsUpdateInterval: UInt32 = 0
    var _gpsAttemptTime: UInt32 = 0
    var _ignoreIncoming: [UInt32] = []
    var _serialpluginEnabled: Bool = false
    var _serialpluginEcho: Bool = false
    var _serialpluginRxd: UInt32 = 0
    var _serialpluginTxd: UInt32 = 0
    var _serialpluginTimeout: UInt32 = 0
    var _serialpluginMode: UInt32 = 0
    var _extNotificationPluginEnabled: Bool = false
    var _extNotificationPluginOutputMs: UInt32 = 0
    var _extNotificationPluginOutput: UInt32 = 0
    var _extNotificationPluginActive: Bool = false
    var _extNotificationPluginAlertMessage: Bool = false
    var _extNotificationPluginAlertBell: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _positionBroadcastSecs = source._positionBroadcastSecs
      _sendOwnerInterval = source._sendOwnerInterval
      _waitBluetoothSecs = source._waitBluetoothSecs
      _screenOnSecs = source._screenOnSecs
      _phoneTimeoutSecs = source._phoneTimeoutSecs
      _phoneSdsTimeoutSec = source._phoneSdsTimeoutSec
      _meshSdsTimeoutSecs = source._meshSdsTimeoutSecs
      _sdsSecs = source._sdsSecs
      _lsSecs = source._lsSecs
      _minWakeSecs = source._minWakeSecs
      _wifiSsid = source._wifiSsid
      _wifiPassword = source._wifiPassword
      _wifiApMode = source._wifiApMode
      _region = source._region
      _chargeCurrent = source._chargeCurrent
      _isRouter = source._isRouter
      _isLowPower = source._isLowPower
      _fixedPosition = source._fixedPosition
      _factoryReset = source._factoryReset
      _debugLogEnabled = source._debugLogEnabled
      _locationShare = source._locationShare
      _gpsOperation = source._gpsOperation
      _gpsUpdateInterval = source._gpsUpdateInterval
      _gpsAttemptTime = source._gpsAttemptTime
      _ignoreIncoming = source._ignoreIncoming
      _serialpluginEnabled = source._serialpluginEnabled
      _serialpluginEcho = source._serialpluginEcho
      _serialpluginRxd = source._serialpluginRxd
      _serialpluginTxd = source._serialpluginTxd
      _serialpluginTimeout = source._serialpluginTimeout
      _serialpluginMode = source._serialpluginMode
      _extNotificationPluginEnabled = source._extNotificationPluginEnabled
      _extNotificationPluginOutputMs = source._extNotificationPluginOutputMs
      _extNotificationPluginOutput = source._extNotificationPluginOutput
      _extNotificationPluginActive = source._extNotificationPluginActive
      _extNotificationPluginAlertMessage = source._extNotificationPluginAlertMessage
      _extNotificationPluginAlertBell = source._extNotificationPluginAlertBell
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._positionBroadcastSecs) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._sendOwnerInterval) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._waitBluetoothSecs) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._screenOnSecs) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._phoneTimeoutSecs) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._phoneSdsTimeoutSec) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._meshSdsTimeoutSecs) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._sdsSecs) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._lsSecs) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._minWakeSecs) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._wifiSsid) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._wifiPassword) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._wifiApMode) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._region) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._chargeCurrent) }()
        case 32: try { try decoder.decodeSingularEnumField(value: &_storage._locationShare) }()
        case 33: try { try decoder.decodeSingularEnumField(value: &_storage._gpsOperation) }()
        case 34: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsUpdateInterval) }()
        case 36: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsAttemptTime) }()
        case 37: try { try decoder.decodeSingularBoolField(value: &_storage._isRouter) }()
        case 38: try { try decoder.decodeSingularBoolField(value: &_storage._isLowPower) }()
        case 39: try { try decoder.decodeSingularBoolField(value: &_storage._fixedPosition) }()
        case 100: try { try decoder.decodeSingularBoolField(value: &_storage._factoryReset) }()
        case 101: try { try decoder.decodeSingularBoolField(value: &_storage._debugLogEnabled) }()
        case 103: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._ignoreIncoming) }()
        case 120: try { try decoder.decodeSingularBoolField(value: &_storage._serialpluginEnabled) }()
        case 121: try { try decoder.decodeSingularBoolField(value: &_storage._serialpluginEcho) }()
        case 122: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialpluginRxd) }()
        case 123: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialpluginTxd) }()
        case 124: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialpluginTimeout) }()
        case 125: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialpluginMode) }()
        case 126: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationPluginEnabled) }()
        case 127: try { try decoder.decodeSingularUInt32Field(value: &_storage._extNotificationPluginOutputMs) }()
        case 128: try { try decoder.decodeSingularUInt32Field(value: &_storage._extNotificationPluginOutput) }()
        case 129: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationPluginActive) }()
        case 130: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationPluginAlertMessage) }()
        case 131: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationPluginAlertBell) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._positionBroadcastSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._positionBroadcastSecs, fieldNumber: 1)
      }
      if _storage._sendOwnerInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sendOwnerInterval, fieldNumber: 2)
      }
      if _storage._waitBluetoothSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._waitBluetoothSecs, fieldNumber: 4)
      }
      if _storage._screenOnSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._screenOnSecs, fieldNumber: 5)
      }
      if _storage._phoneTimeoutSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._phoneTimeoutSecs, fieldNumber: 6)
      }
      if _storage._phoneSdsTimeoutSec != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._phoneSdsTimeoutSec, fieldNumber: 7)
      }
      if _storage._meshSdsTimeoutSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._meshSdsTimeoutSecs, fieldNumber: 8)
      }
      if _storage._sdsSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sdsSecs, fieldNumber: 9)
      }
      if _storage._lsSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lsSecs, fieldNumber: 10)
      }
      if _storage._minWakeSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minWakeSecs, fieldNumber: 11)
      }
      if !_storage._wifiSsid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._wifiSsid, fieldNumber: 12)
      }
      if !_storage._wifiPassword.isEmpty {
        try visitor.visitSingularStringField(value: _storage._wifiPassword, fieldNumber: 13)
      }
      if _storage._wifiApMode != false {
        try visitor.visitSingularBoolField(value: _storage._wifiApMode, fieldNumber: 14)
      }
      if _storage._region != .unset {
        try visitor.visitSingularEnumField(value: _storage._region, fieldNumber: 15)
      }
      if _storage._chargeCurrent != .maunset {
        try visitor.visitSingularEnumField(value: _storage._chargeCurrent, fieldNumber: 16)
      }
      if _storage._locationShare != .locUnset {
        try visitor.visitSingularEnumField(value: _storage._locationShare, fieldNumber: 32)
      }
      if _storage._gpsOperation != .gpsOpUnset {
        try visitor.visitSingularEnumField(value: _storage._gpsOperation, fieldNumber: 33)
      }
      if _storage._gpsUpdateInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsUpdateInterval, fieldNumber: 34)
      }
      if _storage._gpsAttemptTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsAttemptTime, fieldNumber: 36)
      }
      if _storage._isRouter != false {
        try visitor.visitSingularBoolField(value: _storage._isRouter, fieldNumber: 37)
      }
      if _storage._isLowPower != false {
        try visitor.visitSingularBoolField(value: _storage._isLowPower, fieldNumber: 38)
      }
      if _storage._fixedPosition != false {
        try visitor.visitSingularBoolField(value: _storage._fixedPosition, fieldNumber: 39)
      }
      if _storage._factoryReset != false {
        try visitor.visitSingularBoolField(value: _storage._factoryReset, fieldNumber: 100)
      }
      if _storage._debugLogEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._debugLogEnabled, fieldNumber: 101)
      }
      if !_storage._ignoreIncoming.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._ignoreIncoming, fieldNumber: 103)
      }
      if _storage._serialpluginEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._serialpluginEnabled, fieldNumber: 120)
      }
      if _storage._serialpluginEcho != false {
        try visitor.visitSingularBoolField(value: _storage._serialpluginEcho, fieldNumber: 121)
      }
      if _storage._serialpluginRxd != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialpluginRxd, fieldNumber: 122)
      }
      if _storage._serialpluginTxd != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialpluginTxd, fieldNumber: 123)
      }
      if _storage._serialpluginTimeout != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialpluginTimeout, fieldNumber: 124)
      }
      if _storage._serialpluginMode != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialpluginMode, fieldNumber: 125)
      }
      if _storage._extNotificationPluginEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationPluginEnabled, fieldNumber: 126)
      }
      if _storage._extNotificationPluginOutputMs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._extNotificationPluginOutputMs, fieldNumber: 127)
      }
      if _storage._extNotificationPluginOutput != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._extNotificationPluginOutput, fieldNumber: 128)
      }
      if _storage._extNotificationPluginActive != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationPluginActive, fieldNumber: 129)
      }
      if _storage._extNotificationPluginAlertMessage != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationPluginAlertMessage, fieldNumber: 130)
      }
      if _storage._extNotificationPluginAlertBell != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationPluginAlertBell, fieldNumber: 131)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RadioConfig.UserPreferences, rhs: RadioConfig.UserPreferences) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._positionBroadcastSecs != rhs_storage._positionBroadcastSecs {return false}
        if _storage._sendOwnerInterval != rhs_storage._sendOwnerInterval {return false}
        if _storage._waitBluetoothSecs != rhs_storage._waitBluetoothSecs {return false}
        if _storage._screenOnSecs != rhs_storage._screenOnSecs {return false}
        if _storage._phoneTimeoutSecs != rhs_storage._phoneTimeoutSecs {return false}
        if _storage._phoneSdsTimeoutSec != rhs_storage._phoneSdsTimeoutSec {return false}
        if _storage._meshSdsTimeoutSecs != rhs_storage._meshSdsTimeoutSecs {return false}
        if _storage._sdsSecs != rhs_storage._sdsSecs {return false}
        if _storage._lsSecs != rhs_storage._lsSecs {return false}
        if _storage._minWakeSecs != rhs_storage._minWakeSecs {return false}
        if _storage._wifiSsid != rhs_storage._wifiSsid {return false}
        if _storage._wifiPassword != rhs_storage._wifiPassword {return false}
        if _storage._wifiApMode != rhs_storage._wifiApMode {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._chargeCurrent != rhs_storage._chargeCurrent {return false}
        if _storage._isRouter != rhs_storage._isRouter {return false}
        if _storage._isLowPower != rhs_storage._isLowPower {return false}
        if _storage._fixedPosition != rhs_storage._fixedPosition {return false}
        if _storage._factoryReset != rhs_storage._factoryReset {return false}
        if _storage._debugLogEnabled != rhs_storage._debugLogEnabled {return false}
        if _storage._locationShare != rhs_storage._locationShare {return false}
        if _storage._gpsOperation != rhs_storage._gpsOperation {return false}
        if _storage._gpsUpdateInterval != rhs_storage._gpsUpdateInterval {return false}
        if _storage._gpsAttemptTime != rhs_storage._gpsAttemptTime {return false}
        if _storage._ignoreIncoming != rhs_storage._ignoreIncoming {return false}
        if _storage._serialpluginEnabled != rhs_storage._serialpluginEnabled {return false}
        if _storage._serialpluginEcho != rhs_storage._serialpluginEcho {return false}
        if _storage._serialpluginRxd != rhs_storage._serialpluginRxd {return false}
        if _storage._serialpluginTxd != rhs_storage._serialpluginTxd {return false}
        if _storage._serialpluginTimeout != rhs_storage._serialpluginTimeout {return false}
        if _storage._serialpluginMode != rhs_storage._serialpluginMode {return false}
        if _storage._extNotificationPluginEnabled != rhs_storage._extNotificationPluginEnabled {return false}
        if _storage._extNotificationPluginOutputMs != rhs_storage._extNotificationPluginOutputMs {return false}
        if _storage._extNotificationPluginOutput != rhs_storage._extNotificationPluginOutput {return false}
        if _storage._extNotificationPluginActive != rhs_storage._extNotificationPluginActive {return false}
        if _storage._extNotificationPluginAlertMessage != rhs_storage._extNotificationPluginAlertMessage {return false}
        if _storage._extNotificationPluginAlertBell != rhs_storage._extNotificationPluginAlertBell {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    2: .same(proto: "user"),
    3: .same(proto: "position"),
    7: .same(proto: "snr"),
    5: .standard(proto: "next_hop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.num) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.nextHop) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.snr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.num != 0 {
      try visitor.visitSingularUInt32Field(value: self.num, fieldNumber: 1)
    }
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.nextHop != 0 {
      try visitor.visitSingularUInt32Field(value: self.nextHop, fieldNumber: 5)
    }
    if self.snr != 0 {
      try visitor.visitSingularFloatField(value: self.snr, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NodeInfo, rhs: NodeInfo) -> Bool {
    if lhs.num != rhs.num {return false}
    if lhs._user != rhs._user {return false}
    if lhs._position != rhs._position {return false}
    if lhs.snr != rhs.snr {return false}
    if lhs.nextHop != rhs.nextHop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MyNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MyNodeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "my_node_num"),
    2: .standard(proto: "has_gps"),
    3: .standard(proto: "num_channels"),
    4: .same(proto: "region"),
    5: .standard(proto: "hw_model"),
    6: .standard(proto: "firmware_version"),
    7: .standard(proto: "error_code"),
    8: .standard(proto: "error_address"),
    9: .standard(proto: "error_count"),
    10: .standard(proto: "packet_id_bits"),
    11: .standard(proto: "current_packet_id"),
    12: .standard(proto: "node_num_bits"),
    13: .standard(proto: "message_timeout_msec"),
    14: .standard(proto: "min_app_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.myNodeNum) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasGps_p) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numChannels) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.hwModel) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.firmwareVersion) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.errorAddress) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.errorCount) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.packetIDBits) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.currentPacketID) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.nodeNumBits) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.messageTimeoutMsec) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.minAppVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.myNodeNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.myNodeNum, fieldNumber: 1)
    }
    if self.hasGps_p != false {
      try visitor.visitSingularBoolField(value: self.hasGps_p, fieldNumber: 2)
    }
    if self.numChannels != 0 {
      try visitor.visitSingularInt32Field(value: self.numChannels, fieldNumber: 3)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 4)
    }
    if !self.hwModel.isEmpty {
      try visitor.visitSingularStringField(value: self.hwModel, fieldNumber: 5)
    }
    if !self.firmwareVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.firmwareVersion, fieldNumber: 6)
    }
    if self.errorCode != .none {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 7)
    }
    if self.errorAddress != 0 {
      try visitor.visitSingularUInt32Field(value: self.errorAddress, fieldNumber: 8)
    }
    if self.errorCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.errorCount, fieldNumber: 9)
    }
    if self.packetIDBits != 0 {
      try visitor.visitSingularUInt32Field(value: self.packetIDBits, fieldNumber: 10)
    }
    if self.currentPacketID != 0 {
      try visitor.visitSingularUInt32Field(value: self.currentPacketID, fieldNumber: 11)
    }
    if self.nodeNumBits != 0 {
      try visitor.visitSingularUInt32Field(value: self.nodeNumBits, fieldNumber: 12)
    }
    if self.messageTimeoutMsec != 0 {
      try visitor.visitSingularUInt32Field(value: self.messageTimeoutMsec, fieldNumber: 13)
    }
    if self.minAppVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.minAppVersion, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MyNodeInfo, rhs: MyNodeInfo) -> Bool {
    if lhs.myNodeNum != rhs.myNodeNum {return false}
    if lhs.hasGps_p != rhs.hasGps_p {return false}
    if lhs.numChannels != rhs.numChannels {return false}
    if lhs.region != rhs.region {return false}
    if lhs.hwModel != rhs.hwModel {return false}
    if lhs.firmwareVersion != rhs.firmwareVersion {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorAddress != rhs.errorAddress {return false}
    if lhs.errorCount != rhs.errorCount {return false}
    if lhs.packetIDBits != rhs.packetIDBits {return false}
    if lhs.currentPacketID != rhs.currentPacketID {return false}
    if lhs.nodeNumBits != rhs.nodeNumBits {return false}
    if lhs.messageTimeoutMsec != rhs.messageTimeoutMsec {return false}
    if lhs.minAppVersion != rhs.minAppVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LogRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "time"),
    3: .same(proto: "source"),
    4: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.time) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularFixed32Field(value: self.time, fieldNumber: 2)
    }
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 3)
    }
    if self.level != .unset {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LogRecord, rhs: LogRecord) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.time != rhs.time {return false}
    if lhs.source != rhs.source {return false}
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogRecord.Level: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    5: .same(proto: "TRACE"),
    10: .same(proto: "DEBUG"),
    20: .same(proto: "INFO"),
    30: .same(proto: "WARNING"),
    40: .same(proto: "ERROR"),
    50: .same(proto: "CRITICAL"),
  ]
}

extension FromRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FromRadio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "num"),
    2: .same(proto: "packet"),
    3: .standard(proto: "my_info"),
    4: .standard(proto: "node_info"),
    6: .same(proto: "radio"),
    7: .standard(proto: "log_record"),
    8: .standard(proto: "config_complete_id"),
    9: .same(proto: "rebooted"),
    10: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.num) }()
      case 2: try {
        var v: MeshPacket?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .packet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .packet(v)}
      }()
      case 3: try {
        var v: MyNodeInfo?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .myInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .myInfo(v)}
      }()
      case 4: try {
        var v: NodeInfo?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .nodeInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .nodeInfo(v)}
      }()
      case 6: try {
        var v: RadioConfig?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .radio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .radio(v)}
      }()
      case 7: try {
        var v: LogRecord?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .logRecord(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .logRecord(v)}
      }()
      case 8: try {
        if self.variant != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.variant = .configCompleteID(v)}
      }()
      case 9: try {
        if self.variant != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.variant = .rebooted(v)}
      }()
      case 10: try {
        var v: ChannelSettings?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .channel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .channel(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.num != 0 {
      try visitor.visitSingularUInt32Field(value: self.num, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.variant {
    case .packet?: try {
      guard case .packet(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .myInfo?: try {
      guard case .myInfo(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .nodeInfo?: try {
      guard case .nodeInfo(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .radio?: try {
      guard case .radio(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .logRecord?: try {
      guard case .logRecord(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .configCompleteID?: try {
      guard case .configCompleteID(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }()
    case .rebooted?: try {
      guard case .rebooted(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }()
    case .channel?: try {
      guard case .channel(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FromRadio, rhs: FromRadio) -> Bool {
    if lhs.num != rhs.num {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ToRadio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ToRadio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packet"),
    100: .standard(proto: "want_config_id"),
    101: .standard(proto: "set_radio"),
    102: .standard(proto: "set_owner"),
    103: .standard(proto: "set_channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MeshPacket?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .packet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .packet(v)}
      }()
      case 100: try {
        if self.variant != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.variant = .wantConfigID(v)}
      }()
      case 101: try {
        var v: RadioConfig?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .setRadio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .setRadio(v)}
      }()
      case 102: try {
        var v: User?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .setOwner(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .setOwner(v)}
      }()
      case 103: try {
        var v: ChannelSettings?
        if let current = self.variant {
          try decoder.handleConflictingOneOf()
          if case .setChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.variant = .setChannel(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.variant {
    case .packet?: try {
      guard case .packet(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wantConfigID?: try {
      guard case .wantConfigID(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 100)
    }()
    case .setRadio?: try {
      guard case .setRadio(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .setOwner?: try {
      guard case .setOwner(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .setChannel?: try {
      guard case .setChannel(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ToRadio, rhs: ToRadio) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
